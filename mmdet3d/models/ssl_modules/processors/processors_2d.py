import torch
from torch.nn import functional as F

from mmdet3d.models.fusion_layers.coord_transform import bbox_2d_transform
from mmdet.core import bbox2roi
from ...builder import SSL_MODULES
from ..bbox_utils import filter_by_nms_2d
from ..utils import mlvl_get, mlvl_getattr, mlvl_set


@SSL_MODULES.register_module
class SimpleTest_2D():
    """Gets pre-nms test bboxes.

    Generated by following the line for Faster-RCNN.     faster_rcnn.py,
    two_stage.py, base_roi_head.py, standard_roi_head.py,     test_mixins.py,
    bbox_head.py
    """
    def __init__(self,
                 ssl_obj_attr='teacher',
                 batch_dict_key='tea',
                 out_bboxes_key='2d_simple_test'):

        self.ssl_obj_attr = ssl_obj_attr
        self.batch_dict_key = batch_dict_key
        self.out_bboxes_key = out_bboxes_key

    def forward(self, ssl_obj, batch_dict):
        """out_bboxes is a list of tuples (Bbox preds N x 4, scores N x
        (num_classes + 1))

        Not NMS'ed, Not unscaled or flipped or anything.
        """
        detector = mlvl_getattr(ssl_obj, self.ssl_obj_attr)
        curr_batch_dict = mlvl_get(batch_dict, self.batch_dict_key)
        img_metas = curr_batch_dict['img_metas']

        ## two_stage.py simple_test
        x = detector.extract_feat(curr_batch_dict['img'])
        proposal_list = \
            detector.rpn_head.simple_test_rpn(x, img_metas)

        ## standard_roi_head.py simple_test
        ## -> test_mixins.py simple_test_bboxes
        rois = bbox2roi(proposal_list)

        ## standard_roi_head.py _bbox_forward
        bbox_feats = detector.roi_head.bbox_roi_extractor(
            x[:detector.roi_head.bbox_roi_extractor.num_inputs], rois)
        if detector.roi_head.with_shared_head:
            bbox_feats = detector.roi_head.shared_head(bbox_feats)
        cls_score, bbox_pred = detector.roi_head.bbox_head(bbox_feats)

        ## test_mixins.py simple_test_bboxes
        img_shapes = tuple(meta['img_shape'] for meta in img_metas)

        # split batch bbox prediction back to each image
        num_proposals_per_img = tuple(len(p) for p in proposal_list)
        rois = rois.split(num_proposals_per_img, 0)
        cls_score = cls_score.split(num_proposals_per_img, 0)
        bbox_pred = bbox_pred.split(num_proposals_per_img, 0)
        # bbox_feats = bbox_feats.split(num_proposals_per_img, 0)

        out_bboxes = []
        ## bbox_head.py get_bboxes
        # Note: Regardless of sigmoid or not, fasterrcnn has num_classes + 1
        # cls outputs
        for i in range(len(num_proposals_per_img)):
            use_sigmoid_cls = getattr(
                detector.roi_head.bbox_head.loss_cls, 'use_sigmoid', False)
            if use_sigmoid_cls:
                score = torch.sigmoid(cls_score[i])
            else:
                score = F.softmax(cls_score[i], dim=-1)

            bboxes = detector.roi_head.bbox_head.bbox_coder.decode(
                rois[i][..., 1:], bbox_pred[i], max_shape=img_shapes[i])

            out_bboxes.append((bboxes, score))

        curr_batch_dict[self.out_bboxes_key] = out_bboxes

        return batch_dict


@SSL_MODULES.register_module
class BboxesNMS_2D():
    def __init__(self,
                 nms_cfg,
                 cls_includes_bg_pred,
                 batch_dict_key='stu',
                 in_bboxes_key='3d_bboxes_nms_2d_proj',
                 out_bboxes_key='3d_bboxes_nms_2d_proj_2d_nms'):

        # cls_includes_bg_pred is important - NMS function requires a
        # pseudo "background" class prediction. So, if cls_includes_bg_pred is
        # True, it means the class scores already are of length num_class + 1,
        # so need to additionally add an extra at the end.
        # In practice, SECOND needs cls_includes_bg_pred to be False, 2D
        # detector needs it to be True.
        self.cls_includes_bg_pred = cls_includes_bg_pred
        self.nms_cfg = nms_cfg
        self.batch_dict_key = batch_dict_key
        self.in_bboxes_key = in_bboxes_key
        self.out_bboxes_key = out_bboxes_key

    def forward(self, ssl_obj, batch_dict):
        """
        Args:
            ssl_obj: a pointer to the main SSL class object
            batch_dict:
                [batch_dict_key]:
                    [in_bboxes_key]: list[tuple(bboxes, scores, **)]
                        bboxes is bbox class N x 4
                        scores is tensor N x num_classes

        Returns: Additions:
            batch_dict:
                [batch_dict_key]:
                    [out_bboxes_key]:
        TODO: This only works when scores is indeed a probability distribution
            It can definitely be adapted to be class-agnostic.
        """
        curr_batch_dict = mlvl_get(batch_dict, self.batch_dict_key)

        curr_batch_dict[self.out_bboxes_key] = \
            filter_by_nms_2d(curr_batch_dict[self.in_bboxes_key],
                             self.nms_cfg,
                             not self.cls_includes_bg_pred)

        return batch_dict


@SSL_MODULES.register_module
class BboxesTransform_2D():
    """Takes 2D bboxes and transforms them either forward or backward based on
    2D augs in passed img_metas.

    "Forward" - if img_metas has resize 2x, bboxes are resized 2x
    "Reverse" - if img_metas has resize 2x, bboxes are resized 1/2x
    """
    def __init__(self,
                 reverse,
                 img_metas,
                 in_bboxes_key,
                 out_bboxes_key):

        self.reverse = reverse
        self.img_metas = img_metas
        self.in_bboxes_key = in_bboxes_key
        self.out_bboxes_key = out_bboxes_key

    def forward(self, ssl_obj, batch_dict):
        """
        Args:
            [in_bboxes_key]: Can either be:
                - list(tensor). Inner tensor is just the 2d bboxes. (like GT)
                - list(tuple). The first element of the tuple are
                    the bboxes N x (>=4). The tuple can be arbitrary length
                    after.
                    TODO: I think additional consideration is needed if some
                    boxes are invalid after aug, but this only happens for
                    crop I believe.
        """
        img_metas = mlvl_get(batch_dict, self.img_metas)
        in_bboxes = mlvl_get(batch_dict, self.in_bboxes_key)

        out_bboxes = []
        for batch_idx, (curr_in_bboxes, img_meta) in \
                enumerate(zip(in_bboxes, img_metas)):

            if isinstance(curr_in_bboxes, tuple):
                curr_in_bboxes_2d = curr_in_bboxes[0]
                rest = curr_in_bboxes[1:]
            else:
                assert isinstance(curr_in_bboxes, torch.Tensor)
                curr_in_bboxes_2d = curr_in_bboxes

            assert curr_in_bboxes_2d.shape[1] >= 4

            # ori2new is "forward"
            curr_in_bboxes_2d = bbox_2d_transform(img_meta, curr_in_bboxes_2d,
                                                  not self.reverse)

            if isinstance(curr_in_bboxes, tuple):
                out_bboxes.append((curr_in_bboxes_2d, *rest))
            else:
                out_bboxes.append(curr_in_bboxes_2d)

        mlvl_set(batch_dict, self.out_bboxes_key, out_bboxes)

        return batch_dict


@SSL_MODULES.register_module
class AverageBboxes_2D():
    # Note: removes the bg class prediction
    def __init__(self,
                 cls_includes_bg_pred_1,
                 cls_includes_bg_pred_2,
                 in_bboxes_1_key,
                 in_bboxes_2_key,
                 out_bboxes_key,
                 out_score_type='averaged'):
        self.cls_includes_bg_pred_1 = cls_includes_bg_pred_1
        self.cls_includes_bg_pred_2 = cls_includes_bg_pred_2
        self.in_bboxes_1_key = in_bboxes_1_key
        self.in_bboxes_2_key = in_bboxes_2_key
        self.out_bboxes_key = out_bboxes_key
        self.out_score_type = out_score_type

    def forward(self, ssl_obj, batch_dict):
        in_bboxes_1 = mlvl_get(batch_dict, self.in_bboxes_1_key)
        in_bboxes_2 = mlvl_get(batch_dict, self.in_bboxes_2_key)

        out_bboxes = []
        for batch_idx, (curr_in_1, curr_in_2) in \
                enumerate(zip(in_bboxes_1, in_bboxes_2)):

            avged_bboxes = (curr_in_1[0] + curr_in_2[0]) / 2

            curr_in_score_1 = curr_in_1[1]
            curr_in_score_2 = curr_in_2[1]

            if self.out_score_type == 'averaged':
                if self.cls_includes_bg_pred_1:
                    curr_in_score_1 = curr_in_score_1[:, :-1]

                if self.cls_includes_bg_pred_2:
                    curr_in_score_2 = curr_in_score_2[:, :-1]

                out_score = (curr_in_score_1 + curr_in_score_2) / 2
            elif self.out_score_type == 'pred_1':
                out_score = curr_in_score_1
            elif self.out_score_type == 'pred_2':
                out_score = curr_in_score_2

            out_bboxes.append((avged_bboxes, out_score))

        mlvl_set(batch_dict, self.out_bboxes_key, out_bboxes)

        return batch_dict